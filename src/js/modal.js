// modal.js
// Модуль для управления модальным окном (popup/modal)
// Здесь реализованы функции открытия, закрытия и инициализации модального окна.
// Код снабжён подробными обучающими комментариями для самостоятельного изучения.

// modal — глобальная переменная, в которую мы сохраняем DOM-элемент модального окна.
// Это позволяет обращаться к модалке из разных функций.
let modal;

// modalTimerId — переменная для хранения идентификатора таймера автопоказа модалки.
// Таймер нужен, чтобы через определённое время автоматически показать окно пользователю.
let modalTimerId;

/**
 * Открывает модальное окно
 * — Проверяет, что элемент модалки найден
 * — Добавляет класс, делающий модалку видимой ("modal--active")
 * — Блокирует прокрутку страницы (overflow: hidden)
 * — Сбрасывает таймер автопоказа, чтобы окно не открылось повторно
 *
 * Почему важно блокировать прокрутку? Чтобы пользователь не мог скроллить страницу, пока открыта модалка.
 * Почему нужен clearTimeout? Если пользователь открыл окно вручную, автотаймер больше не нужен.
 */
export function openModal() {
    if (!modal) return; // Проверяем, что модалка существует
    modal.classList.add("modal--active"); // Делаем модалку видимой
    document.body.style.overflow = "hidden"; // Блокируем прокрутку страницы
    clearTimeout(modalTimerId); // Сбрасываем таймер автопоказа
}

/**
 * Закрывает модальное окно
 * — Проверяет, что элемент модалки найден
 * — Удаляет класс видимости ("modal--active"), скрывая окно
 * — Возвращает прокрутку страницы (overflow: "")
 * — Удаляет все окна с сообщением "спасибо" (.modal__dialog--thanks)
 * — Возвращает основную форму/диалог в модалке в видимое состояние
 *
 * Почему удаляем "спасибо"-модалки? Чтобы при повторном открытии показывалась только форма, а не старое сообщение.
 * Почему возвращаем форму? Чтобы пользователь мог снова заполнить и отправить её.
 */
export function closeModal() {
    if (!modal) return; // Проверяем, что модалка существует

    modal.classList.remove("modal--active"); // Скрываем модалку
    document.body.style.overflow = ""; // Возвращаем прокрутку страницы

    // Удаляем все "спасибо" окна (модалки с сообщением)
    modal.querySelectorAll(".modal__dialog--thanks").forEach((n) => n.remove());

    // Возвращаем основную форму/диалог в модалке в видимое состояние
    const mainDialog = modal.querySelector(".modal__dialog");
    if (mainDialog) {
        mainDialog.classList.add("show");
        mainDialog.classList.remove("hide");
    }
}

/**
 * Инициализирует работу модального окна
 * — modalSelector: CSS-селектор модального окна (например, '.modal')
 * — triggerSelector: CSS-селектор кнопок/элементов, открывающих модалку (например, '[data-modal]')
 * — closeOnOverlay: закрывать ли модалку по клику на подложку (overlay)
 *
 * Как работает:
 * 1. Находит модальное окно и все триггеры (кнопки/ссылки), которые должны его открывать
 * 2. Навешивает обработчик на каждый триггер — при клике открывается модалка
 * 3. Навешивает обработчик на само модальное окно — если клик по overlay или по крестику, окно закрывается
 * 4. Навешивает обработчик на document — если нажата клавиша Escape и модалка открыта, окно закрывается
 * 5. Запускает таймер автопоказа модалки через 50 секунд (можно изменить)
 * 6. Навешивает обработчик на scroll — если пользователь доскроллил до конца страницы, модалка открывается
 *
 * Почему делегируем обработку клика на overlay? Это удобно и надёжно: не нужно искать отдельный элемент подложки.
 * Почему используем таймер и scroll? Это позволяет показать окно тем, кто долго находится на странице или дочитал до конца.
 */
export function initModal({
    modalSelector,
    triggerSelector,
    closeOnOverlay = true,
}) {
    // 1. Получаем DOM-элемент модального окна по селектору
    modal = document.querySelector(modalSelector);
    // 2. Получаем все элементы-триггеры (кнопки/ссылки), которые должны открывать модалку
    const triggers = document.querySelectorAll(triggerSelector);

    // 3. Навешиваем обработчик на каждый триггер для открытия модального окна
    triggers.forEach((btn) => btn.addEventListener("click", openModal));

    // 4. Навешиваем обработчик на само модальное окно для закрытия по overlay или по кнопке закрытия
    modal.addEventListener("click", (e) => {
        // Если клик по overlay (самому модальному окну) и разрешено закрытие по overlay,
        // или если клик по элементу с data-close (крестик)
        if (
            (e.target === modal && closeOnOverlay) ||
            e.target.getAttribute("data-close") !== null
        ) {
            closeModal();
        }
    });

    // 5. Навешиваем обработчик на document для закрытия модалки по клавише Escape
    document.addEventListener("keydown", (e) => {
        // Проверяем, что нажата клавиша Escape и модалка открыта
        if (e.key === "Escape" && modal.classList.contains("modal--active")) {
            closeModal();
        }
    });

    // 6. Запускаем таймер автопоказа модального окна через 50 секунд
    // Это полезно для привлечения внимания пользователя, если он долго на странице
    modalTimerId = setTimeout(openModal, 50000);

    // 7. Функция для показа модалки при прокрутке до конца страницы
    function showModalByScroll() {
        // Если пользователь доскроллил до самого низа страницы
        if (
            window.pageYOffset + document.documentElement.clientHeight >=
            document.documentElement.scrollHeight - 1
        ) {
            openModal();
            window.removeEventListener("scroll", showModalByScroll);
        }
    }

    // 8. Навешиваем обработчик на scroll для автопоказа модалки при достижении конца страницы
    window.addEventListener("scroll", showModalByScroll);
}
// initModal — инициализирует работу модального окна: открытие по кнопке, закрытие по overlay/крестику/Escape, автопоказ по таймеру и при прокрутке
