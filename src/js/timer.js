// timer.js
// Модуль для таймера обратного отсчёта

// Экспортируемая функция для запуска таймера
// selector — CSS-селектор контейнера таймера (например, '.timer')
// deadline — строка с датой окончания отсчёта (например, '2026-05-11')
export function startTimer({ selector, deadline }) {
    // 1. Получаем DOM-элемент, в котором будет отображаться таймер.
    //    Это может быть любой контейнер, например <div class="timer">...</div>
    //    Используем querySelector, чтобы найти элемент по переданному селектору.
    const timer = document.querySelector(selector); // timer — это ссылка на DOM-элемент, который содержит весь таймер
    // 2. Если элемент не найден (например, селектор неверный или элемента нет в HTML),
    //    функция завершает выполнение — таймер не будет инициализирован.
    if (!timer) return;

    // 3. Внутри контейнера таймера ищем элементы, куда будем выводить значения:
    //    - дни (id="days")
    //    - часы (id="hours")
    //    - минуты (id="minutes")
    //    - секунды (id="seconds")
    //    Это должны быть, например, <span id="days"></span> и т.д.
    const days = timer.querySelector('#days');   // Элемент для дней
    const hours = timer.querySelector('#hours'); // Элемент для часов
    const minutes = timer.querySelector('#minutes'); // Элемент для минут
    const seconds = timer.querySelector('#seconds'); // Элемент для секунд

    // 4. Вложенная функция getTimeRemaining рассчитывает разницу между дедлайном и текущим временем.
    //    endtime — строка с датой окончания (например, '2026-05-11')
    //    Возвращает объект с:
    //      - total: общее количество миллисекунд до дедлайна
    //      - days: количество полных дней
    //      - hours: остаток часов
    //      - minutes: остаток минут
    //      - seconds: остаток секунд
    //    Почему так: удобно сразу получить все значения для отображения и для проверки окончания таймера.
    function getTimeRemaining(endtime) {
        // Date.parse(endtime) — преобразует строку в миллисекунды с 1 января 1970
        // Date.parse(new Date()) — текущее время в миллисекундах
        // t — разница между дедлайном и текущим временем
        const t = Date.parse(endtime) - Date.parse(new Date());
        // days — целое число дней до дедлайна
        // Math.max(..., 0) — если дедлайн прошёл, не даём уйти в минус (будет 0)
        const days = Math.max(Math.floor(t / (1000 * 60 * 60 * 24)), 0);
        // hours — остаток часов после вычитания полных дней
        const hours = Math.max(Math.floor((t / (1000 * 60 * 60)) % 24), 0);
        // minutes — остаток минут после вычитания полных часов
        const minutes = Math.max(Math.floor((t / (1000 * 60)) % 60), 0);
        // seconds — остаток секунд после вычитания полных минут
        const seconds = Math.max(Math.floor((t / 1000) % 60), 0);
        // Возвращаем объект с рассчитанными значениями
        return { total: t, days, hours, minutes, seconds };
    }

    // 5. Функция getZero форматирует числа: если число < 10, добавляет ведущий ноль (например, 7 → '07').
    //    Это делается для красивого отображения времени (09:05:03 вместо 9:5:3).
    //    Почему так: привычный вид таймера для пользователя.
    function getZero(num) {
        return num >= 0 && num < 10 ? `0${num}` : num;
    }

    // 6. Функция updateClock обновляет значения на странице (вызывается каждую секунду).
    //    Она:
    //      - получает объект с оставшимся временем до дедлайна
    //      - обновляет содержимое элементов для дней, часов, минут, секунд
    //      - если время вышло (total <= 0), останавливает таймер (clearInterval)
    //    Почему так: чтобы значения на странице всегда были актуальны, а после дедлайна не уходили в минус.
    function updateClock() {
        // Получаем объект с оставшимся временем до дедлайна
        const t = getTimeRemaining(deadline);
        // days.textContent — обновляем содержимое элемента для дней
        days.textContent = getZero(t.days);
        // hours.textContent — обновляем содержимое элемента для часов
        hours.textContent = getZero(t.hours);
        // minutes.textContent — обновляем содержимое элемента для минут
        minutes.textContent = getZero(t.minutes);
        // seconds.textContent — обновляем содержимое элемента для секунд
        seconds.textContent = getZero(t.seconds);
        // Если время вышло (total <= 0), останавливаем таймер, чтобы не было отрицательных значений
        if (t.total <= 0) {
            clearInterval(timeInterval);
        }
    }

    // 7. Сразу вызываем updateClock, чтобы не ждать первую секунду (иначе на странице будет старое значение)
    updateClock();
    // 8. Запускаем интервал: updateClock будет вызываться каждую секунду (1000 мс)
    //    Почему так: чтобы таймер обновлялся в реальном времени
    const timeInterval = setInterval(updateClock, 1000);
}
